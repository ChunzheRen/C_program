C语言中的.与->的差别：

C的早期实现无法用结构直接作为参数在函数间传递，仅仅能用指向结构的指针在函数间进行传递。
a->b 也就是 （*a）.b     

稍微有c【的基A的同W可能知道，在C器a和【的角度砜矗不存在量，不存在 struct @N|西，只存在寄存器和一叫做却娴拇到M。

变量就是C对于内存地址的一个抽象，代表了一个位置。
a=b 在汇编中更像是 *a=*b;

struct 是什么？ 
struct Point {
	int x;
	int y;
};
struct Point p;//一个实例化的对象
struct Point *pp = &p;//pp是指向p的指针

【的Zx上v， p 是一不完整的地址，或者f，半地址，再或者f，一指向的|西是出淼牡刂贰６ x 和 y 各是在 Point Y中的地址偏移量。也就是f，必有 p 和 x 或者 p 和 y 同r出F，才形成一完整的地址，为的一 p ]有意x。

早期的 C 就是在@拥哪Ｐ蜕辖立的。所以υ缙诘 C 而言， *pp ]有意x，你取得了一 struct ，而@ struct 不能塞在任何一寄存器Y，g器和 CPU 都o法表_@|西。

@r候只有 p.x 和 p.y 有意x，它有真的地址。
struct 仅仅是你的p.x和 p.y的一个存储位置。
仅仅当你的p是包括了实例化的p.x和 p.y 之后，才叫做一个真实的地址。

p.x = 1;
int *a=&p.x;//有意义

(*pp).x=1没有任何意义，因为没有办法翻译成为机器代码。
所以υ缙诘 C 而言， pp 解引用的操作，必和取成T的偏移的操作，@烧呔o密Y合起碜成一为的操作，其Y果u有意x。

现在来说 p->x=1； 与 (*p).x；是等价的。
反正就是C/Cpp里面的class一旦出现了struct，就最好使用->箭头运算符号。























