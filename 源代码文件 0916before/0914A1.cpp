//笔记 
#include <stdio.h>
#include <stdlib.h>
#define EOF (-1)
while (c=getchar()!=EOF){ //wrong  
	putchar(c);
}
 while ((c=getchar)!= EOF){}
//注意运算符运算的优先级：
//！= 
//= 

行计数
#include <stdio.h >
void main(){
	int c,n1;
	while((c=getchar())!=EOF){
		if (c='\n'){
			n1++;
		}
		printf("%d\n",n1);
	}
}
//逻辑运算符号 


*void是通用指针的意思。 


//链表的判断条件:指针是不是空的，以及指针元素是不是存在着的。
while(cts<length && p)  基本的语句就是那几句。
malloc(sizeof(struct LNode))----------------------free() 
//视频笔记
2017年9月14日21:29:01 
//你就是昨晚没想休息好，现在累了，所以情绪非常的不好。
//掌握计数器和指针之间的关系，然后就是关于链表操作中的指针，其实是不需malloc空间的，然后只需要将指针指向一个有空间的链表结点即可。
//然后就是关于链表自身，完全是需要被分配一个空间的，也就是说链表需要malloc而指针不需要malloc。
//顺序表和链表的时间复杂度是不一样的。 

//求两个集合的并，B中拿出一个元素，在A中去寻找这个元素是不是存在，如果不存在的话就执行插入操作。 
//取决于基本操作的时间 和控制结构的时间
//顺序表的前提下面的 集合本身用线性表来1表示的时候是没有顺序的
算法一：merge操作，也就是把B中与A不重复的元素赋值给A。
算法二： purge净化操作，也就是删除重复的元素 

//集合如果不是有序的话，差别在于线性表里面的数据元素是不是按照数值进行有序的排列。
// ？？？？为什么这么说啊 
如果用线性表来表示集合的时候，尽量对于线性集合先进行排序。
用有序表来表示集合比用无序表表示集合要好。 

GetElem 和 ListInsert在顺序表和链表中的时间复杂度是不一样的。
链表都是和表长成正比，因为需要从头找到尾巴。 对于算法二是平方级别的。

MergeList 单纯的完全归并
基本的操作，比较两个数据元素，然后就是插入 

就是要分清楚不同的算法在不同的存储方式下面的时间复杂度。
不必在意函数细节，只需要做出来就行，主要是不同的方式和表长的关系来判断时间复杂度。
 
 链表的长度是难知道的，但是可以用后一个元素是空来判断是不是到达了末尾。
 单链表地最后一个元素的插入是需要遍历整个链表的。缺少指向最后一一个节点的信息。 
 链表中，元素的位序被淡化 ，而是位置更强化。也就是用头指针来指向第i和节点，然后用计数器来计数以便找到节点。
 
 需要改变链表的设置来解决上述问题 ――增加表长的域，则更加指向表尾节点的一个域。
 由于指针的移动，增加一个指向当前指针的域。 
 表长 表尾指针 当前位置的指针 ――三个域
 链表的基本操作由位置顺序变成指针。  
 
 带有头结点的线性链表―――即使是有STL模板类来实现不同的数据结构，也同样有着不同的操作。
单链表线性列表――结点不变，然后就是用MakeNode来分配一个节点的空间，用FreeNode来释放一个节点。 
链表的生成都需要一个动态存储空间的分配。 最重要的就是及时free


结点类型 有三个结点 然后一个链表长度   升级版单链表 
InitList 头指针 尾指针 当前指针 都指向头结点 表长为0 ;
基本操作：结构的初始化和结构的销毁。 
求前驱和后继  

重置为空表 ――尾巴 当前 以及表长都要改变
在最后一个结点后面加上一串结点 其实在尾部插入的话，一个节点还是一串结点是没有差别的。

 当前指针不存在的时候就不呢能够插入了，但是如果存在当前指针的前提下哈市可以插入的。
 主要就是注意你的指针是不是可以被插入的。
 
我觉得对于数域节点的单链表你已经掌握的差不多
不必拘泥于函数 
主要是要充分考虑到循环条件以及循环的成功的判断。

尝试用新的链表的形式来进行操作。
INITLIST INSERTELEM  CLEAR DESTROY GETELEM LOCATEELEM  HEADINSERT TAILINSERT DISPLAY PIRORELEM NEXTELEM SIMPLIFY ASCEND DESCEND 
基本操作也太多了吧。。。。。 
还有就是排序之后的merge操作，两个线性表得到另外一个线性表
分别去两个表里面的结点，然后进行判断大小，然后就是对于结点进行挨个的插入，
还有就是删除当前指针后面的元素 
 
  
 
