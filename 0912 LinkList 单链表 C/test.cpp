//注释参考Vs 0912单链表系列 
//以及没有深入研究尾端插入，没有实际测试插入
//2017年9月12日20:30:32
//Arthur：Justin.SHAOHUI.CHUNZHE.Ren  
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>>

typedef int ElemType;
typedef struct LNode {
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;


int InitList(LinkList*L) {
	//(*L) = (LNode*)malloc(sizeof(struct LNode));
	(*L) = (LinkList)malloc(sizeof(struct LNode));
	//??????????,?????????????
	if (!(*L)) return 0;  //exit(0)????
	(*L)->next = NULL;
	//??????????????
	printf("successfully initialized\n");
	return 0;
}

//??????????
int DestroyList(LinkList L) {
	LinkList q;//??????,????????
	while (L) {
		q = (L)->next;//q???????????
		free(L);//??????????????
		//????? L????,??????????
		//free????L???????,??????L????
		L = q;//???????,???????,???q??L
	}//??????L?????
	return 0;//????0??????
}

//C??????????????


//??????,LinkList???*,??Linklist??????
//????LNode *L??,??????????
//??*?????
int ClearList(LinkList L) {
	LinkList p, q;//???????? 
	p = (L)->next;//????. ????*
	while (p) {//?????????,?????????
		q = p->next;
		free(p);
		q = p;//??????????????
	}
	L->next = NULL;
	return 0;
}//clearlist???????????????????????

int ListEmpty(LinkList L) {
	if (L->next)
		return 0;
	else 
		return -1;
}


int Listlength(LinkList L) {
	int i = 0;
	LinkList p = L->next;   //p??????????
	while (p) {
		i++;				//???????
							//???????????
		p = p->next;		//p???????
	}
	return i;//???????
}

int GetElem(LinkList L, int pos, ElemType *e) {
	//???????pos??
	int cts = 0;
	//p??????1?
	LNode *p =L->next;
	for (; ((p != 0) && (cts < pos));cts++) { 
		p = p->next;//???????
	}				

	if ((!p ) || cts > pos) {
		return 0;} 
	*e = p->data; 
	return 1;
}
//???????????
int LocateElem(LinkList L, ElemType e) {
	//????????,??????????
	LinkList p = L->next;
	int cts = 0;
	while (p) {
		if (p->data == e) {
			printf("found the element: %d.\n", e);
			return 1;
		}
		p += 1;
	}
	printf("oops! Unable to find %d.\n", e);
	return -1; 
}
//??????,????????
//????malloc??????????,??????????????????,????????????????????
int PriorElem(LinkList L, ElemType cur_e, ElemType *prev_e) {
	LinkList p = L->next;
	while (p->next)
	{
		LinkList q = p->next;
		if (q->data == cur_e) {
			*prev_e = p->data;
			return 1;
		}
		p = p->next;
	}
	return -1;
}
//L->next ???????????????
int NextElem(LinkList L, ElemType cur_e, ElemType *next_e) {
	LinkList p = L->next;//????????????
	while (p->next) {
		if (p->data == cur_e) {
			*next_e = (p->next)->data;
		}
	}
	return -1;
}

int InsertList(LinkList *L, ElemType e, int pos) {
	if (pos < 1) return 0;
	int cts = 0;
	LinkList p = *L;
	while (p && cts < pos) {
		p += 1;
		cts++;
	}
	//???????????
	//???????
	if (!p || cts > pos) {
		return -1;
	}
	LinkList s = (LinkList)malloc(sizeof(LinkList));
	s->data = e; //??????????????
	s->next = p->next;
	p->next = s;
	return 1;
}
int main() {
	LinkList La;
	InitList(&La);
	return 0;
		
}






